#!/bin/bash
# Ensures the script is executed using the Bash shell.

# --- SCRIPT SETUP ---
# Change the current directory to the project's root.
# The '|| exit 1' part ensures the script will fail immediately if the directory doesn't exist.
cd codebase/android || exit 1

# --- CHECK FOR STAGED CHANGES ---
# Check if there are any files staged for commit.
# 'git diff --cached --quiet' exits with 1 if there are staged changes, and 0 otherwise.
# The '!' inverts the exit code, so the 'if' block runs when changes are present.
if ! git diff --cached --quiet; then
    echo "Staged changes detected. Running tests..."
else
    echo "No staged changes to commit. Skipping tests."
    exit 0
fi

# --- IDENTIFY RELEVANT FILES ---
# Get a list of all staged Kotlin and Java files that have been Added (A), Copied (C), or Modified (M).
# This prevents running tests for deleted files or files of other types.
staged_files=$(git diff --cached --name-only --diff-filter=ACM "*.kt" "*.java")

# If no relevant files were staged, there's no need to run tests.
if [ -z "$staged_files" ]; then
    echo "No Kotlin or Java files staged. Skipping tests."
    exit 0
fi

# --- FIND AFFECTED MODULES ---
# Initialize an empty string to collect all module paths. We add '\n' as a delimiter
# to make it easy to process this string as a multi-line list later.
raw_module_list=""

echo "Identifying modules from staged files:"
for file in $staged_files; do
    echo "Processing file: $file"
    # Use a regular expression to extract the Gradle module name from the file path.
    # It captures the directory name found between 'codebase/android/' and the first '/src/'.
    if [[ "$file" =~ ^codebase/android/([^/]+)/src/ ]]; then
        # The captured module name is stored in the BASH_REMATCH array.
        module_name="${BASH_REMATCH[1]}"

        # Convert the directory name (e.g., "feature-accounts") into a Gradle path (e.g., ":feature-accounts").
        if [[ "$module_name" == "app" ]]; then
            gradle_module_path=":app"
        else
            gradle_module_path=":$module_name"
        fi

        echo "Found module: $gradle_module_path for file $file"
        # Add the found module to our raw list, followed by a newline character.
        raw_module_list+="${gradle_module_path}\n"
    else
        echo "No module pattern matched for file: $file"
    fi
done

# --- DE-DUPLICATE MODULES ---
# This pipeline processes the raw list to create a clean, de-duplicated array of modules.
final_unique_modules_array=()
if [ -n "$raw_module_list" ]; then
    # The 'while read' loop is a safe, backwards-compatible way to read line-by-line input.
    # 1. `printf "%b"`: Reliably interprets the '\n' characters to turn our string into a stream of lines.
    # 2. `sed '/^$/d'`: Removes any empty lines that might have crept in.
    # 3. `sort -u`: Sorts the lines and removes all duplicates.
    # 4. The loop reads each unique line from the pipeline and adds it to the final array.
    while IFS= read -r module; do
        final_unique_modules_array+=("$module")
    done < <(printf "%b" "$raw_module_list" | sed '/^$/d' | sort -u)
fi

# --- BUILD THE GRADLE COMMAND ---
# Initialize an empty string to build the list of test tasks.
test_commands=""
# If the array is empty (meaning no modules were identified), default to running all tests as a safeguard.
if [ ${#final_unique_modules_array[@]} -eq 0 ]; then
    echo "Could not determine modules for staged files. Running all tests as a fallback..."
    test_commands="testDebugUnitTest"
else
    # If we have unique modules, build a specific test command for each one.
    echo "Unique modules to test:"
    for module in "${final_unique_modules_array[@]}"; do
        echo "- $module"
        test_commands+="${module}:testDebugUnitTest "
    done
    # Remove the trailing space from the end of the command string.
    test_commands=$(echo "$test_commands" | sed 's/ *$//')
fi

# Final check to ensure we have a command to run.
if [ -z "$test_commands" ]; then
    echo "No test commands to run."
    exit 0
fi

# --- EXECUTE TESTS ---
# Assemble the final command and print it for visibility.
CMD="./gradlew $test_commands"
echo "Executing: $CMD"

# Run the Gradle command.
$CMD
# Capture the exit code of the last command. 0 means success, anything else is a failure.
RESULT=$?

# --- HANDLE TEST RESULTS ---
# If the exit code is not 0, the tests failed.
if [ $RESULT -ne 0 ]; then
    echo "Tests failed. Commit aborted."
    # Exit with a non-zero status code to block the commit.
    exit 1
fi

echo "All specified tests passed."
# Exit with 0 to indicate success and allow the commit to proceed.
exit 0
